"""
PDF Processor for E-Sign.
Handles PDF manipulation using PyMuPDF (fitz) and ReportLab.
"""
import os
import fitz  # PyMuPDF
import hashlib
from django.conf import settings
from django.core.files.base import ContentFile
from django.utils import timezone
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter, A4
from reportlab.lib import colors
from reportlab.lib.utils import ImageReader
import io
import logging

logger = logging.getLogger('apps.esign')

class PDFProcessor:
    def __init__(self, file_path=None, stream=None):
        """
        Initialize with file path or stream.
        """
        self.doc = None
        try:
            if file_path:
                self.doc = fitz.open(file_path)
            elif stream:
                self.doc = fitz.open(stream=stream, filetype="pdf")
            else:
                raise ValueError("Either file_path or stream must be provided")
        except Exception as e:
            logger.error(f"Failed to open PDF: {str(e)}")
            raise

    def get_page_count(self):
        return len(self.doc)

    def get_page_dimensions(self, page_num):
        """
        Get dimensions of a specific page.
        page_num is 1-based.
        Returns (width, height) tuple.
        """
        try:
            if page_num < 1 or page_num > len(self.doc):
                raise ValueError(f"Invalid page number: {page_num}")
            
            page = self.doc.load_page(page_num - 1)
            rect = page.rect
            return rect.width, rect.height
        except Exception as e:
            logger.error(f"Failed to get page dimensions: {str(e)}")
            raise

    def generate_thumbnails(self, output_dir, dpi=72):
        """
        Generate thumbnails for all pages.
        Returns list of relative paths to thumbnails.
        """
        thumbnails = []
        try:
            if not os.path.exists(output_dir):
                os.makedirs(output_dir)

            for page_num in range(len(self.doc)):
                page = self.doc.load_page(page_num)
                pix = page.get_pixmap(dpi=dpi)
                
                filename = f"page_{page_num + 1}.png"
                filepath = os.path.join(output_dir, filename)
                pix.save(filepath)
                thumbnails.append(filename)
                
            return thumbnails
        except Exception as e:
            logger.error(f"Failed to generate thumbnails: {str(e)}")
            raise

    def embed_signature(self, signature_image_path, page_num, x, y, width, height):
        """
        Embed signature image onto a specific page.
        Coordinates are in points (72 dpi).
        page_num is 1-based.
        """
        try:
            if page_num < 1 or page_num > len(self.doc):
                raise ValueError(f"Invalid page number: {page_num}")

            if not os.path.exists(signature_image_path):
                raise FileNotFoundError(f"Signature image not found: {signature_image_path}")

            page = self.doc.load_page(page_num - 1)
            page_rect = page.rect
            
            logger.info(f"Embedding signature on page {page_num}. Page size: {page_rect.width}x{page_rect.height}")
            logger.info(f"Signature rect: x={x}, y={y}, w={width}, h={height}")
            
            # Check if coordinates are likely inverted (PDF bottom-left vs PyMuPDF top-left)
            # If y is very large (near page height) and height is small, it might be bottom-left
            # But we'll trust the input for now, just logging warning if off-page
            
            if x < 0 or y < 0 or x + width > page_rect.width or y + height > page_rect.height:
                logger.warning(f"Signature might be off-page! Page: {page_rect}, Sig: {x},{y},{width},{height}")

            # Define rectangle for signature
            # PyMuPDF uses (x0, y0, x1, y1)
            rect = fitz.Rect(x, y, x + width, y + height)
            
            # Insert image
            page.insert_image(rect, filename=signature_image_path)
            
        except Exception as e:
            logger.error(f"Failed to embed signature: {str(e)}")
            raise

    def add_audit_page(self, audit_data):
        """
        Append an audit trail page to the PDF.
        audit_data: dict containing session details and events
        """
        try:
            # Create audit page using ReportLab
            packet = io.BytesIO()
            c = canvas.Canvas(packet, pagesize=A4)
            width, height = A4
            
            # Header
            c.setFont("Helvetica-Bold", 16)
            c.drawString(50, height - 50, "Audit Trail")
            
            c.setFont("Helvetica", 10)
            c.setFillColor(colors.grey)
            c.drawString(50, height - 70, f"Generated by SmartFileTools E-Sign on {timezone.now().strftime('%Y-%m-%d %H:%M:%S')}")
            
            # Session Details
            y = height - 100
            c.setFillColor(colors.black)
            c.setFont("Helvetica-Bold", 12)
            c.drawString(50, y, "Session Details")
            y -= 20
            
            c.setFont("Helvetica", 10)
            details = [
                f"Session ID: {audit_data.get('session_id')}",
                f"Status: {audit_data.get('status')}",
                f"Created: {audit_data.get('created_at')}",
                f"Signer: {audit_data.get('signer_name')} ({audit_data.get('signer_email')})",
                f"Original File Hash: {audit_data.get('original_hash')}",
            ]
            
            for line in details:
                c.drawString(50, y, line)
                y -= 15
                
            y -= 20
            
            # Signatures
            c.setFont("Helvetica-Bold", 12)
            c.drawString(50, y, "Signatures")
            y -= 20
            
            c.setFont("Helvetica", 10)
            for sig in audit_data.get('signatures', []):
                c.drawString(50, y, f"â€¢ Signed by {sig['signer']} on {sig['signed_at']}")
                y -= 15
                c.setFillColor(colors.grey)
                c.drawString(70, y, f"IP: {sig['ip_address']} | ID: {sig['id']}")
                c.setFillColor(colors.black)
                y -= 20
                
            # Audit Events
            y -= 20
            c.setFont("Helvetica-Bold", 12)
            c.drawString(50, y, "Event Log")
            y -= 20
            
            c.setFont("Helvetica", 9)
            for event in audit_data.get('events', []):
                # Check for page break
                if y < 50:
                    c.showPage()
                    y = height - 50
                    c.setFont("Helvetica", 9)
                
                c.drawString(50, y, f"{event['timestamp']} - {event['type']}")
                y -= 15
            
            c.save()
            packet.seek(0)
            
            # Merge ReportLab PDF with PyMuPDF
            audit_pdf = fitz.open("pdf", packet.read())
            self.doc.insert_pdf(audit_pdf)
            
        except Exception as e:
            logger.error(f"Failed to add audit page: {str(e)}")
            raise

    def save(self, output_path=None):
        """
        Save the modified PDF.
        Returns bytes if output_path is None.
        """
        try:
            if output_path:
                self.doc.save(output_path)
                return output_path
            else:
                return self.doc.tobytes()
        except Exception as e:
            logger.error(f"Failed to save PDF: {str(e)}")
            raise

    def close(self):
        if self.doc:
            self.doc.close()

    @staticmethod
    def calculate_hash(file_path):
        """Calculate SHA-256 hash of a file"""
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()
